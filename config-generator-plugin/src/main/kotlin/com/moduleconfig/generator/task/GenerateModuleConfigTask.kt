package com.moduleconfig.generator.task

import com.moduleconfig.generator.extension.ModuleConfigField
import com.moduleconfig.generator.inteface.ConfigValue
import com.squareup.javapoet.*
import org.gradle.api.DefaultTask
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.provider.Provider
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.OutputDirectory
import org.gradle.api.tasks.TaskAction
import java.util.*
import javax.lang.model.element.Modifier

open class GenerateModuleConfigTask : DefaultTask() {
    
    @get:Input
    lateinit var packageName: String
    
    @get:Input
    lateinit var className: String
    
    @get:Input
    lateinit var fields: List<ModuleConfigField>

    @get:Input
    lateinit var namespace: Provider<String>
    
    @get:OutputDirectory
    val outputDir: DirectoryProperty = project.objects.directoryProperty()
    
    @TaskAction
    fun generateBuildConfig() {
        // 确保输出目录存在
        val outputDirectory = outputDir.get().asFile
        outputDirectory.mkdirs()

        val classPackageName = if (packageName.isNotBlank()) packageName else namespace.get()
        // 创建类构建器
        val classBuilder = TypeSpec.classBuilder(className)
            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
        
        // 添加类注释
        classBuilder.addJavadoc("Generated ModuleConfig class\n")
        classBuilder.addJavadoc("Generated at: \$L\n", Date().toString())
        
        // 添加私有构造函数
        val constructor = MethodSpec.constructorBuilder()
            .addModifiers(Modifier.PRIVATE)
            .addStatement("// Utility class")
            .build()
        classBuilder.addMethod(constructor)
        
        // 添加字段
        fields.forEach { field ->
            addFieldToClass(classBuilder, field)
        }
        
        // 生成 toString 方法
        addToStringMethod(classBuilder)
        
        // 创建 Java 文件
        val javaFile = JavaFile.builder(classPackageName, classBuilder.build())
            .addFileComment("Generated by ModuleConfig Generator Plugin")
            .build()
        
        // 写入文件
        javaFile.writeTo(outputDirectory)
        
        project.logger.info("Generated ${className}.java in package ${classPackageName}")
    }
    
    private fun addFieldToClass(classBuilder: TypeSpec.Builder, field: ModuleConfigField) {
        // 创建字段规格构建器
        val fieldBuilder = FieldSpec.builder(
            getTypeName(field.type),
            field.name
        )
        
        // 添加修饰符
        val modifiers = mutableListOf<Modifier>()
        
        when (field.visibility) {
            "public" -> modifiers.add(Modifier.PUBLIC)
            "private" -> modifiers.add(Modifier.PRIVATE)
            "protected" -> modifiers.add(Modifier.PROTECTED)
        }
        
        if (field.isStatic) {
            modifiers.add(Modifier.STATIC)
        }
        
        if (field.isFinal) {
            modifiers.add(Modifier.FINAL)
        }
        
        fieldBuilder.addModifiers(*modifiers.toTypedArray())
        
        // 添加初始值
        fieldBuilder.initializer(getInitializerCode(field))
        
        // 添加注释
        if (field.comment.isNotEmpty()) {
            fieldBuilder.addJavadoc(field.comment + "\n")
        }
        
        classBuilder.addField(fieldBuilder.build())
    }
    
    private fun getTypeName(type: String): TypeName {
        return when (type.lowercase()) {
            "string" -> ClassName.get(String::class.java)
            "int", "integer" -> TypeName.INT
            "long" -> TypeName.LONG
            "float" -> TypeName.FLOAT
            "double" -> TypeName.DOUBLE
            "boolean" -> TypeName.BOOLEAN
            "byte" -> TypeName.BYTE
            "short" -> TypeName.SHORT
            "char", "character" -> TypeName.CHAR
            else -> {
                // 尝试解析为类名
                try {
                    if (type.endsWith("[]")) {
                        val elementType = type.substring(0, type.length - 2)
                        val elementTypeName = when (elementType.lowercase()) {
                            "int", "integer" -> TypeName.INT
                            "long" -> TypeName.LONG
                            "float" -> TypeName.FLOAT
                            "double" -> TypeName.DOUBLE
                            "boolean" -> TypeName.BOOLEAN
                            "byte" -> TypeName.BYTE
                            "short" -> TypeName.SHORT
                            "char", "character" -> TypeName.CHAR
                            "string" -> ClassName.get(String::class.java)
                            else -> ClassName.bestGuess(elementType)
                        }
                        ArrayTypeName.of(elementTypeName)
                    } else if (ConfigValue.ListValue.typeCheck(type)){
                        ParameterizedTypeName.get(
                            ClassName.get(List::class.java),
                            ClassName.bestGuess(ConfigValue.ListValue.extractElementType(type)!!)
                        )
                    } else if (ConfigValue.MapValue.typeCheck(type)){
                        ParameterizedTypeName.get(
                            ClassName.get(Map::class.java),
                            ClassName.bestGuess(ConfigValue.MapValue.extractElementType(type)!!.first),
                            ClassName.bestGuess(ConfigValue.MapValue.extractElementType(type)!!.second)
                        )
                    } else {
                        ClassName.bestGuess(type)
                    }
                } catch (e: Exception) {
                    project.logger.warn("Unknown type: $type, using Object")
                    ClassName.get(Any::class.java)
                }
            }
        }
    }
    
    private fun getInitializerCode(field: ModuleConfigField): CodeBlock {
        return if (field.type.lowercase() == "string") {
            val value = field.value
            val cleanValue = if (value.startsWith("\"") && value.endsWith("\"")) {
                value.substring(1, value.length - 1)
            } else {
                value
            }
            // 使用 \$S 格式化符，但确保字符串不会被自动换行
            // 通过将长字符串拆分为多个部分来避免自动换行
            if (cleanValue.length > 50 || cleanValue.contains('\n') || cleanValue.contains('\t') || cleanValue.contains('\r')) {
                // 对于包含特殊字符或过长的字符串，手动转义并使用 \$L
                val escapedValue = cleanValue
                    .replace("\\", "\\\\")
                    .replace("\"", "\\\"")
                    .replace("\n", "\\n")
                    .replace("\t", "\\t")
                    .replace("\r", "\\r")
                CodeBlock.of("\"\$L\"", escapedValue)
            } else {
                CodeBlock.of("\$S", cleanValue)
            }
        } else {
            CodeBlock.of("\$L", field.value)
        }
    }
    
    private fun addToStringMethod(classBuilder: TypeSpec.Builder) {
        val toStringBuilder = MethodSpec.methodBuilder("toString")
            .addAnnotation(Override::class.java)
            .addModifiers(Modifier.PUBLIC)
            .returns(String::class.java)
        
        val format = StringBuilder("${className}{")
        val args = mutableListOf<String>()
        
        fields.forEachIndexed { index, field ->
            if (index > 0) {
                format.append(", ")
            }
            format.append("${field.name}=%s")
            args.add(field.name)
        }
        
        format.append("}")
        
        toStringBuilder.addStatement(
            "return String.format(\$S, \$L)",
            format.toString(),
            args.joinToString(", ")
        )
        
        classBuilder.addMethod(toStringBuilder.build())
    }
}